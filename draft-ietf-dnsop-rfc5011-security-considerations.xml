<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY rfc2119 PUBLIC "" ".//reference.RFC.2119.xml">
<!ENTITY rfc5011 PUBLIC "" ".//reference.RFC.5011.xml">
<!ENTITY rfc7719 PUBLIC "" ".//reference.RFC.7719.xml">
<!ENTITY rfc7583 PUBLIC "" ".//reference.RFC.7583.xml">
]>
<!-- WK: Set category, IPR, docName -->
<rfc category="std"
     docName="draft-ietf-dnsop-rfc5011-security-considerations-08"
     updates="7583"
     ipr="trust200902">
  <?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>

  <?rfc toc="yes" ?>

  <?rfc symrefs="yes" ?>

  <?rfc sortrefs="yes"?>

  <?rfc iprnotified="no" ?>

  <?rfc strict="yes"?>

  <?rfc compact="yes" ?>

  <front>
    <!-- WK: Set long title. -->

    <title abbrev="RFC5011 Security Considerations ">Security Considerations
    for RFC5011 Publishers</title>

    <author fullname="Wes Hardaker" initials="W." surname="Hardaker">
      <organization>USC/ISI</organization>

      <address>
        <postal>
          <street>P.O. Box 382</street>

          <city>Davis, CA</city>

          <code>95617</code>

          <country>US</country>
        </postal>

        <email>ietf@hardakers.net</email>
      </address>
    </author>

    <author fullname="Warren Kumari" initials="W." surname="Kumari">
      <organization>Google</organization>

      <address>
        <postal>
          <street>1600 Amphitheatre Parkway</street>

          <city>Mountain View, CA</city>

          <code>94043</code>

          <country>US</country>
        </postal>

        <email>warren@kumari.net</email>
      </address>
    </author>

    <date day="29" month="Nov" year="2017"/>

    <area>ops</area>

    <workgroup>dnsop</workgroup>

    <abstract>
      <t> This document extends the RFC5011 rollover strategy with
      timing advice that must be followed by the publisher in order to
      maintain security.  Specifically, this document describes the
      math behind the minimum time-length that a DNS zone publisher
      must wait before signing exclusively with recently added
      DNSKEYs.  This document also describes the minimum time-length
      that a DNS zone publisher must wait after publishing a revoked
      DNSKEY before assuming that all active RFC5011 resolvers should
      have seen the revocation-marked key and removed it from their
      list of trust anchors.</t>

      <t>This document contains much math and complicated equations,
      but the summary is that the key rollover / revocation time is
      much longer than intuition would suggest.  If you are not both
      publishing a DNSSEC DNSKEY, and using RFC5011 to advertise this
      DNSKEY as a new Secure Entry Point key for use as a trust
      anchor, you probably don't need to read this document.</t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
      <t><xref target="RFC5011"/> defines a mechanism by which DNSSEC
      validators can update their list of trust anchors when they've
      seen a new key published in a zone or revoke a properly marked
      key from a trust anchor list. However, RFC5011 [intentionally]
      provides no guidance to the publishers of DNSKEYs about how long
      they must wait before switching to exclusively using recently
      published keys for signing records, or how long they must wait
      before ceasing publication of a revoked key. Because of this
      lack of guidance, zone publishers may derive incorrect
      assumptions about safe usage of the RFC5011 DNSKEY advertising,
      rolling and revocation process. This document describes the
      minimum security requirements from a publisher's point of view
      and is intended to complement the guidance offered in RFC5011
      (which is written to provide timing guidance solely to a
      Validating Resolver's point of view).</t>

      <section title="Document History and Motivation">
        <t>To verify this lack of understanding is wide-spread, the
        authors reached out to 5 DNSSEC experts to ask them how long
        they thought they must wait before signing a zone exclusively
        with a new KSK <xref target="RFC4033"/> that was being
        introduced according to the 5011 process. All 5 experts
        answered with an insecure value, and we determined that this
        lack of mathematical understanding might cause security
        concerns in deployment. We hope that this companion document
        to RFC5011 will rectify this understanding and provide better
        guidance to zone publishers that wish to make use of the
        RFC5011 rollover process.</t>
      </section>
        
      <section title="Safely Rolling the Root Zone's KSK in 2017/2018"> 
        <t>One important note about ICANN's (currently in process)
        2017/2018 KSK rollover plan for the root zone: the timing
        values chosen for rolling the KSK in the root zone appear
        completely safe, and are not affected by the timing concerns
        introduced by this draft</t>
      </section>
      <section title="Requirements notation">
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
        "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
        document are to be interpreted as described in <xref
        target="RFC2119"/>.</t>
      </section>
    </section>

    <section title="Background">
      <t>The RFC5011 process describes a process by which a RFC5011
      Resolver may accept a newly published KSK as a trust anchor for
      validating future DNSSEC signed records. It also describes the
      process for publicly revoking a published KSK. This document
      augments that information with additional constraints, from the
      SEP publisher's points of view. Note that this document does not
      define any other operational guidance or recommendations about
      the RFC5011 process and restricts itself to solely the security
      and operational ramifications of switching to exclusively using
      recently added keys or removing revoked keys too soon.</t>

      <t>Failure of a DNSKEY publisher to follow the minimum
      recommendations associated with this draft can result in
      potential denial-of-service attack opportunities against
      validating resolvers.  Failure of a DNSKEY publisher to publish
      a revoked key for a long enough period of time may result in
      RFC5011 Resolvers leaving that key in their trust anchor
      storage beyond the key's expected lifetime.</t>
    </section>

    <section title="Terminology" anchor="terminology">
      <t><list style="hanging">
          <t hangText="SEP Publisher">The entity responsible for
          publishing a DNSKEY (with the Secure Entry Point (SEP) bit
          set) that can be used as a trust anchor.</t>

          <t hangText="Zone Signer">The owner of a zone intending to publish
          a new Key-Signing-Key (KSK) that may become a trust anchor for
          validators following the RFC5011 process.</t>

          <t hangText="RFC5011 Resolver">A DNSSEC
          Resolver that is using
          the RFC5011 processes to track and update trust anchors.</t>

          <t hangText="Attacker">An entity intent on foiling the
          RFC5011 Resolver's ability to successfully adopt the Zone
          Signer's new DNSKEY as a new trust anchor or to prevent the
          RFC5011 Resolver from removing an old DNSKEY from its list
          of trust anchors.</t>

          <!-- should match components later -->
          <t hangText="sigExpirationTime">
	          The amount of time between the
	          DNSKEY RRSIG's Signature Inception field and the Signature
	          Expiration field.
          </t>

      </list></t>

      <t>Also see Section 2 of <xref target="RFC4033" /> and <xref
      target="RFC7719" /> for additional terminology.</t>
    </section>

    <section title="Timing Associated with RFC5011 Processing">
            <t>These sections define a high-level overview of <xref
            target="RFC5011" /> processing.  These steps are not
            sufficient for proper RFC5011 implementation, but provide
            enough background for the reader to follow the discussion
            in this document.  Readers need to fully understand <xref
            target="RFC5011" /> as well to fully comprehend the
            content and importance of this document.</t>

      <section title="Timing Associated with Publication">
        <t>RFC5011's process of safely publishing a new DNSKEY and then
        assuming RFC5011 Resolvers have adopted it for trust
        falls into a number of high-level steps
        to be performed by the SEP Publisher.  This document
        discusses the following scenario, which the principle way
        RFC5011 is currently being used (even though Section 6 of
        RFC5011 suggests having a stand-by key available):</t>

        <t><list style="numbers">
            <t>Publish a new DNSKEY in a zone, but continue to sign
            the zone with the old one.</t>

            <t>Wait a period of time.</t>

            <t>Begin to exclusively use recently published DNSKEYs to sign the
            appropriate resource records.</t>
          </list></t>

        <t>This document discusses the time required to wait during
        step 2 of the above process. Some interpretations of RFC5011
        have erroneously determined that the wait time is equal to
        RFC5011's "hold down time".  <xref target="attack" />
        describes an attack based on this (common) erroneous belief,
        which can result in a denial of service attack against the
        zone.</t>
      </section>

      <section title="Timing Associated with Revocation">
        <t>RFC5011's process of advertising that an old key is to be revoked
        from RFC5011 Resolvers falls into a number of high-level
        steps:</t>

        <t><list style="numbers">
            <t>Set the revoke bit on the DNSKEY to be revoked.</t>

            <t>Sign the revoked DNSKEY with itself.</t>

            <t>Wait a period of time.</t>

            <t>Remove the revoked key from the zone.</t>
          </list></t>

        <t>This document discusses the time required to wait in step 3
        of the above process. Some interpretations of RFC5011 have
        erroneously determined that the wait time is equal to
        RFC5011's "hold down time".  This document describes an attack
        based on this (common) erroneous belief, which results in a
        revoked DNSKEY potentially remaining as a trust anchor in a
        RFC5011 Resolver long past its expected usage.</t>
      </section>
    </section>

    <section anchor="attack" title="Denial of Service Attack Walkthrough">
      <t>This section serves as an illustrative example of the problem
      being discussed in this document.  Note that in order to keep
      the example simple enough to understand, some simplifications
      were made (such as by not creating a set of pre-signed RRSIGs
      and by not using values that result in the addHoldDownTime not
      being evenly divisible by the activeRefresh value); the
      mathematical formulas in <xref target="minimum" /> are, however,
      complete.</t>

      <t>If an attacker is able to provide a RFC5011 Resolver with
      past responses, such as when it is in-path or able to perform
      any number of cache poisoning attacks, the attacker may be able to leave
      compliant RFC5011 Resolvers without an appropriate DNSKEY trust
      anchor. This scenario will remain until an administrator manually fixes
      the situation.</t>

      <t>The time-line below illustrates an example of this situation.</t>

      <section anchor="examplenumbers" title="Enumerated Attack Example">
        <t>The following example settings are used in the example scenario
        within this section: <list style="hanging">
            <t hangText="TTL (all records)">1 day</t>

            <t hangText="sigExpirationTime">10 days</t>

            <t hangText="Zone resigned every">1 day</t>
          </list></t>

        <t>Given these settings, the sequence of events in <xref
        target="timing" /> depicts how a SEP Publisher that
        waits for only the RFC5011 hold time timer length of 30 days
        subjects its users to a potential Denial of Service
        attack. The timing schedule listed below is based on a SEP
        Publisher publishing a new Key Signing Key (KSK), with
        the intent that it will later be used as a trust anchor.  We label
        this publication time as "T+0".  All numbers in this sequence
        refer to days before and after this initial publication
        event. Thus, T-1 is the day before the introduction of the new
        key, and T+15 is the 15th day after the key was introduced
        into the fictitious zone being discussed.</t>

        <t>In this dialog, we consider two keys within the example zone: <list
            style="hanging">
            <t hangText="K_old:">An older KSK and Trust Anchor being replaced.</t>

            <t hangText="K_new:">A new KSK being transitioned into active
            use and expected to become a Trust Anchor via the RFC5011
            automated trust anchor update process.</t>
          </list></t>

        <section title="Attack Timing Breakdown" anchor="timing">
          <t>The steps shows an attack that foils the adoption of a new
          DNSKEY by a 5011 Resolver when the
          SEP Publisher that starts signing and
          publishing with the new DNSKEY too quickly. <list
              style="hanging">
              <t hangText="T-1">The K_old based RRSIGs are being
              published by the Zone Signer.  [It may also be signing
              ZSKs as well, but they are not relevant to this event so
              we will not talk further about them; we are only
              considering the RRSIGs that cover the DNSKEYs in this
              document.]  The Attacker queries for, retrieves and
              caches this DNSKEY set and corresponding RRSIG
              signatures.</t>

              <t hangText="T+0">The Zone Signer adds K_new to their
              zone and signs the zone's key set with K_old. The
              RFC5011 Resolver (later to be under attack) retrieves
              this new key set and corresponding RRSIGs and notices
              the publication of K_new. The RFC5011 Resolver starts
              the (30-day) hold-down timer for K_new.  [Note that in a
              more real-world scenario there will likely be a further
              delay between the point where the Zone Signer publishes
              a new RRSIG and the RFC5011 Resolver notices its
              publication; though not shown in this example, this
              delay is accounted for in the equation in <xref
              target="minimum" /> below]</t>

              <t hangText="T+5">The RFC5011 Resolver queries for the
              zone's keyset per the RFC5011 Active Refresh schedule,
              discussed in Section 2.3 of RFC5011. Instead of
              receiving the intended published keyset, the Attacker
              successfully replays the keyset and associated
              signatures recorded at T-1 to the victim RFC5011
              Resolver. Because the signature lifetime is 10 days (in
              this example), the replayed signature and keyset is
              accepted as valid (being only 6 days old, which is less
              than sigExpirationTime) and the RFC5011 Resolver cancels
              the (30-day) hold-down timer for K_new, per the RFC5011
              algorithm.</t>

              <t hangText="T+10">The RFC5011 Resolver queries for the
              zone's keyset and discovers a signed keyset that
              includes K_new (again), and is signed by K_old.  Note:
              the attacker is unable to replay the records cached at
              T-1, because the signatures have now expired. Thus at
              T+10, the RFC5011 Resolver starts (anew) the hold-timer
              for K_new.</t>

              <t hangText="T+11 through T+29">The RFC5011 Resolver
              continues checking the zone's key set at the prescribed
              regular intervals.  During this period, the attacker can
              no longer replay traffic to their benefit.</t>

              <t hangText="T+30">The Zone Signer knows that this is the first
              time at which some validators might accept K_new as a new trust
              anchor, since the hold-down timer of a RFC5011 Resolver not
              under attack that had queried and retrieved K_new at T+0 would
              now have reached 30 days. However, the hold-down timer of our
              attacked RFC5011 Resolver is only at 20 days.</t>

              <t hangText="T+35">The Zone Signer (mistakenly) believes that
              all validators following the Active Refresh schedule (Section
              2.3 of RFC5011) should have accepted K_new as a the new trust
              anchor (since the hold down time (30 days) + the query
              interval [which is just 1/2 the signature validity
              period in this example] would have passed). However, the
              hold-down timer of our attacked RFC5011 Resolver is
              only at 25 days (T+35 minus T+10); thus the RFC5011
              Resolver won't consider it a valid trust
              anchor addition yet, as the required 30 days have not
              yet elapsed.</t>

              <t hangText="T+36">The Zone Signer, believing K_new is
              safe to use, switches their active signing KSK to K_new
              and publishes a new RRSIG, signed with (only) K_new, covering
              the DNSKEY set. Non-attacked RFC5011 validators, with a
              hold-down timer of at least 30 days, would have accepted
              K_new into their set of trusted keys. But, because our
              attacked RFC5011 Resolver now has a hold-down timer for
              K_new of only 26 days, it failed to ever accept K_new as a
              trust anchor.  Since K_old is no longer being used to
              sign the zone's DNSKEYs, all the DNSKEY records from
              the zone will be treated as invalid.  Subsequently, all
              of the records in the DNS tree below the zone's apex
              will be deemed invalid by DNSSEC.</t>
            </list></t>
        </section>
      </section>
    </section>

    <section anchor="minimum" title="Minimum RFC5011 Timing Requirements">
        <t> This section defines the minimum timing requirements for
        making exclusive use of newly added DNSKEYs and timing
        requirements for ceasing the publication of DNSKEYs to be
        revoked.  First, we define the term components used in both
        equations in <xref target="term" />. </t>


        <section anchor="term" title="Equation Components">
                <section title="addHoldDownTime">
          <t>The addHoldDownTime is defined in Section 2.4.1 of
          <xref target="RFC5011" /> as:</t>


          <t> <figure>
                  <artwork><![CDATA[
    The add hold-down time is 30 days or the expiration time of the
    original TTL of the first trust point DNSKEY RRSet that contained
    the new key, whichever is greater.  This ensures that at least
    two validated DNSKEY RRSets that contain the new key MUST be seen
    by the resolver prior to the key's acceptance.
                  ]]></artwork></figure></t>
                </section>



          <!-- XXX: review this: -->

          <section title="lastSigExpirationTime" anchor="lastSigExpirationTime">
	          <t>
	          The latest value (i.e. the future most date and
	          time) of any RRSig Signature Expiration field
	          covering any DNSKEY RRSet containing only the old
	          trust anchor(s) that are being superseded. Note that
	          for organizations pre-creating signatures this time
	          may be fairly far in the future unless they can be
	          significantly assured that none of their
	          pre-generated signatures can be replayed at a later
	          date.
	          </t>
          </section>

          <!-- must match definition in terminology -->
          <section title="sigExpirationTime" anchor="sigExpirationTime">
	          <t>
	          The amount of time between the
	          DNSKEY RRSIG's Signature Inception field and the Signature
	          Expiration field.
	          </t>
          </section>

      <section title="sigExpirationTimeRemaining">
              <t>sigExpirationTimeRemaining is defined in <xref
              target="terminology" />.</t>
      </section>

      <section title="activeRefresh" anchor="activeRefresh">
      <t>
        activeRefresh time is defined by RFC5011 by
      </t>
      <t><figure>
          <artwork><![CDATA[
  A resolver that has been configured for an automatic update
  of keys from a particular trust point MUST query that trust
  point (e.g., do a lookup for the DNSKEY RRSet and related
  RRSIG records) no less often than the lesser of 15 days, half
  the original TTL for the DNSKEY RRSet, or half the RRSIG
  expiration interval and no more often than once per hour.
                          
              ]]></artwork>
        </figure></t>

      <t> This translates to:</t>
      <t> <figure>
          <artwork><![CDATA[
 activeRefresh = MAX(1 hour,
                     MIN(sigExpirationTime / 2,
                         MAX(TTL of K_old DNSKEY RRSet) / 2,
                         15 days)
                     )
              ]]></artwork>
      </figure></t>
      </section>
      
      <section title="activeRefreshOffset">
      <t>The activeRefreshOffset term must be added for situations
      where the activeRefresh value is not a factor of the
      addHoldDownTime.  Specifically, activeRefreshOffset will be
      "addHoldDownTime % activeRefresh", where % is the mathematical
      mod operator (calculating the remainder in a division problem).
      This will frequently be zero, but could be nearly as large as
      activeRefresh itself.  For simplicity, setting the
      activeRefreshOffset to the activeRefresh value itself is always
      safe.
      </t>
      </section>
      
      <section title="safetyMargin" anchor="safetyMargin">
              <t>The safetyMargin is an extra period of time to account for
              caching, network delays, dropped packets, and other operational
              concerns otherwise beyond the scope of this document.  The value
              operators should chose is highly dependent on the deployment
              situation associated with their zone.  Note that no value of a
              safetyMargin can protect against resolvers that are "down".
              None the less, we do offer the following as one method
              considering reasonable values to select from.</t>
              
              <t>
                      The following list of variables need to be considered
                      when selecting an appropriate safetyMargin value:
              </t>
              
              <t>
                      <list style="hanging">
                              <t hangText="successRate:"> A likely success rate for client queries and retries</t>
                              <t hangText="numResolvers:"> The number of client RFC5011 Resolvers</t>
                      </list>
              </t>

              <t>Note that RFC5011 defines retryTime as:</t>
      <t> <figure>
          <artwork><![CDATA[
      If the query fails, the resolver MUST repeat the query until
      satisfied no more often than once an hour and no less often
      than the lesser of 1 day, 10% of the original TTL, or 10% of
      the original expiration interval.  That is,
      retryTime = MAX (1 hour, MIN (1 day, .1 * origTTL,
                                    .1 * expireInterval)).
              ]]></artwork>
      </figure></t>

              <t>With the successRate and numResolvers values selected
              and the definition of retryTime from RFC5011, one method
              for determining how many retryTime intervals to wait in
              order to reduce the set of uncompleted servers to 0
              assuming normal probability is thus:
              </t>
              
              <t> <figure>
                      <artwork><![CDATA[
                      x = (1/(1 - successRate))

         retryCountWait = Log_base_x(numResolvers)
                      ]]></artwork>
              </figure></t>

              <t>To reduce the need for readers to pull out a
              scientific calculator, we offer the following lookup
              table based on successRate and numResolvers:</t>

      <t> <figure>
          <artwork><![CDATA[
                       retryCountWait lookup table
                       ---------------------------

                      Number of client RFC5011 Resolvers (numResolvers)
                      -------------------------------------------------
                       10,000  100,000 1,000,000 10,000,000 100,000,000
                0.01      917     1146      1375       1604        1833
Probability     0.05      180      225       270        315         360
of Success      0.10       88      110       132        153         175
Per Retry       0.15       57       71        86        100         114
Interval        0.25       33       41        49         57          65
(successRate)   0.50       14       17        20         24          27
                0.90        4        5         6          7           8
                0.95        4        4         5          6           7
                0.99        2        3         3          4           4
                0.999       2        2         2          3           3
              ]]></artwork>
      </figure></t>

      <t>Finally, a suggested value of safetyMargin can then be this
      retryCountWait number multiplied by the retryTime from RFC5011:
      </t>
      
      <t> <figure>
          <artwork><![CDATA[
              safetyMargin = retryCountWait * retryTime
              ]]></artwork>
      </figure></t>

              </section>
        
      </section>

      <section title="Timing Requirements For Adding a New KSK">

        <t><xref target="waittime" /> defines a method for calculating
        the amount of time to wait until it is safe to start signing
        exclusively with a new DNSKEY (especially useful for writing
        code involving sleep based timers), and <xref
        target="wallclock" /> defines a method for calculating a
        wall-clock value after which it is safe to start signing
        exclusively with a new DNSKEY (especially useful for writing
        code based on clock-based event triggers).
        </t>
        
      <section title="Wait Timer Based Calculation" anchor="waittime">
      <t>Given the attack description in <xref target="attack"/>, the
      correct minimum length of time required for the Zone Signer to
      wait after publishing K_new but before exclusively using it and
      newer keys is:</t>

      <t> <figure>
          <artwork><![CDATA[
   addWaitTime = addHoldDownTime
                 + sigExpirationTimeRemaining
                 + activeRefresh
                 + activeRefreshOffset
                 + safetyMargin
              ]]></artwork>
      </figure></t>

      <section title="Fully expanded equation">
      <t>
               Given the equation components defined in <xref
               target="term" />, the full expanded equation is:
      </t>

      <t> <figure>
          <artwork><![CDATA[
   addWaitTime = addHoldDownTime
                 + sigExpirationTimeRemaining
                 + MAX(1 hour,
                       MIN(sigExpirationTime / 2,
                           MAX(TTL of K_old DNSKEY RRSet) / 2,
                           15 days)
                       )
                 + (addHoldDownTime % activeRefresh)
                 + MAX(1.5 hours, 2 * MAX(TTL of all records))
                 + safetyMargin
              ]]></artwork>
      </figure></t>
      </section>
      </section>

      <section title="Wall-Clock Based Calculation" anchor="wallclock">
	      <t>The equations in <xref target="waittime" />
	      are defined based upon how long
              to wait from a particular moment in time.  An
              alternative, but equivalent, method is to calculate the
              date and time before which it is unsafe to use a key for
              signing.  This calculation thus becomes:</t>

      <t> <figure>
          <artwork><![CDATA[
   addWallClockTime = lastSigExpirationTime
                    + addHoldDownTime
                    + activeRefresh
                    + activeRefreshOffset
                    + safetyMargin
              ]]></artwork>
      </figure></t>

      <t>where lastSigExpirationTime is the latest value of any
      sigExpirationTime for which RRSIGs were created that could
      potentially be replayed.  Fully expanded, this becomes:</t>
              
      <t> <figure>
          <artwork><![CDATA[
   addWallClockTime = lastSigExpirationTime
                      + addHoldDownTime
                      + 2 * MAX(1 hour,
                                MIN(sigExpirationTime / 2,
                                    MAX(TTL of K_old DNSKEY RRSet) / 2,
                                    15 days)
                                )
                      + (addHoldDownTime % activeRefresh)
                      + MAX(1.5 hours, 2 * MAX(TTL of all records))
                      + safetyMargin
              ]]></artwork>
          </figure>
      </t>

      </section>


      <section title="Timing Constraint Summary">
      <t>The important timing constraint introduced by this memo
      relates to the last point at which a RFC5011 Resolver may have
      received a replayed original DNSKEY set, containing K_old and
      not K_new.  The next query of the RFC5011 validator at which
      K_new will be seen without the potential for a replay attack
      will occur after the old DNSKEY RRSIG's Signature Expriation
      Time. Thus, the latest time that a RFC5011 Validator may begin
      their hold down timer is an "Active Refresh" period after the
      last point that an attacker can replay the K_old DNSKEY set.
      The worst case scenario of this attack is if the attacker can
      replay K_old just seconds before the (DNSKEY RRSIG Signature
      Validity) field of the last K_old only RRSIG. </t>
      </section>

<!-- this is duplication and badly worded ; first sentence moved above
     too -->
<!--
      <t>The "Active Refresh" interval used by a RFC5011 validator is
      determined by the larger of (DNSKEY RRSIG Signature Validity)
      and (original TTL for the DNSKEY RRSet). The Following text
      assumes that (DNSKEY RRSIG Signature Validity) is larger of the
      two, which is operationally more common today.</t>

      <t>The worst case scenario of this attack is when the attacker
      can replay K_old seconds before the (DNSKEY RRSIG Signature
      Validity) field of the last K_old only RRSIG. If a RFC5011
      validator picks up K_old at this this point, it will not have a
      hold down timer started as it will have been reset by previous
      replays. It's not until the next "Active Refresh" time that
      they'll pick up K_new with assurance, and thus start their
      (final) hold down timer. Thus, this is not at (DNSKEY RRSIG
      Signature Validity) time past publication but may be
      significantly longer based on the zone's DNSSEC parameters.</t>
-->

      <section title="Additional Considerations for RFC7583">
      <t>Note: our notion of addWaitTime is
      called "Itrp" in Section 3.3.4.1 of <xref target="RFC7583"/>.
      The equation for Itrp in RFC7583 is insecure as it does not
      include the sigExpirationTime listed above.  The Itrp equation
      in RFC7583 also does not include the 2*TTL safety margin, though
      that is an operational consideration.</t>
      </section>

      <section title="Example Scenario Calculations">
      <t>For the parameters listed in <xref target="examplenumbers"/>,
      the activeRefreshOffset is 0, since 30 days is evenly divisible
      by activeRefresh (1/2 day), and our resulting addWaitTime is:
      <figure>
          <artwork><![CDATA[
  addWaitTime = 30
                + 10
                + 1 / 2 
                + 0              (days)

  addWaitTime = 42.5             (days)
                                ]]></artwork>
        </figure></t>

      <t>This addWaitTime of 42.5 days is 12.5 days longer than just
      the hold down timer, even with the needed safetyMargin value
      being left out (which we exclude due to the lack of necessary
      operational parameters).</t>
      </section>

      </section>

      <section title="Timing Requirements For Revoking an Old KSK" anchor="revoking">

        <t>This issue affects not just the
        publication of new DNSKEYs intended to be used as trust anchors,
        but also the length of time required to continuously publish a
        DNSKEY with the revoke bit set.</t>

      <t><xref target="waittime" /> defines a method for calculating
        the amount of time operators need to wait until it is safe to
        cease publishing a DNSKEY (especially useful for writing code
        involving sleep based timers), and <xref target="wallclock" />
        defines a method for calculating a minimal wall-clock value
        after which it is safe to cease publishing a DNSKEY
        (especially useful for writing code based on clock-based event
        triggers).
        </t>

      <section title="Wait Timer Based Calculation">
      <t>Both of these publication
      timing requirements are affected by the attacks described in
      this document, but with revocation the key is revoked
      immediately and the addHoldDown timer does not apply.  Thus the
      minimum amount of time that a SEP Publisher must wait
      before removing a revoked key from publication is: </t>
      <t> <figure>
          <artwork><![CDATA[
  remWaitTime = sigExpirationTimeRemaining
                + activeRefresh
                + safetyMargin

  remWaitTime = sigExpirationTimeRemaining
                + MAX(1 hour,
                      MIN((sigExpirationTime) / 2,
                          MAX(TTL of K_old DNSKEY RRSet) / 2,
                          15 days))
                + safetyMargin
              ]]></artwork>
        </figure></t>

      <t>Note that the activeRefreshOffset time does not apply to this
      equation.</t>

      <t>Note also that adding retryTime intervals to the remWaitTime
      may be wise, just as it was for addWaitTime in <xref
      target="minimum" />.</t>
      </section>

      <section title="Wall-Clock Based Calculation">
              <t>Like before, the above equations are defined based
              upon how long to wait from a particular moment in time.
              An alternative, but equivalent, method is to calculate
              the date and time before which it is unsafe to cease
              publishing a revoked key.  This calculation thus
              becomes:</t>

      <t> <figure>
          <artwork><![CDATA[
   remWallClockTime = lastSigExpirationTime
                    + activeRefresh
                    + safetyMargin

   remWallClockTime = lastSigExpirationTime
                    + MAX(1 hour,
                          MIN((sigExpirationTime) / 2,
                              MAX(TTL of K_old DNSKEY RRSet) / 2,
                              15 days))
                    + safetyMargin
              ]]></artwork>
      </figure></t>

      <t>where lastSigExpirationTime is the latest value of any
      sigExpirationTime for which RRSIGs were created that could
      potentially be replayed.  Fully expanded, this becomes:</t>
              
      </section>

      <section title="Additional Considerations for RFC7583">
      <t>Note that our notion of remWaitTime is
      called "Irev" in Section 3.3.4.2 of <xref target="RFC7583"/>.
      The equation for Irev in RFC7583 is insecure as it does not
      include the sigExpirationTime listed above.    The Irev equation
      in RFC7583 also does not include a safety margin, though
      that is an operational consideration.</t>
      </section>

      <section title="Example Scenario Calculations">
      <t>For the parameters listed in <xref target="examplenumbers"/>, our
      example: <figure>
          <artwork><![CDATA[
  remwaitTime = 10
                + 1 / 2          (days)
     
  remwaitTime = 10.5             (days)
                                ]]></artwork>
        </figure></t>

      <t>Note that for the values in this example produce a length
      shorter than the recommended 30 days in RFC5011's section 6.6,
      step 3.  Other values of sigExpirationTime and the original TTL
      of the K_old DNSKEY RRSet, however, can produce values longer
      than 30 days.</t>

      <t>Note that because revocation happens immediately, an attacker
      has a much harder job tricking a RFC5011 Resolver into leaving
      a trust anchor in place, as the attacker must successfully
      replay the old data for every query a RFC5011 Resolver sends,
      not just one.</t>
      </section>
    </section>
</section>

    <section title="IANA Considerations">
      <t>This document contains no IANA considerations.</t>
    </section>

    <section anchor="operational" title="Operational Considerations">
      <t>A companion document to RFC5011 was expected to be published
      that describes the best operational practice considerations from
      the perspective of a zone publisher and SEP
      Publisher. However, this companion document has yet to be
      published. The authors of this document hope that it will at
      some point in the future, as RFC5011 timing can be tricky as we
      have shown, and a BCP is clearly warranted.  This document is
      intended only to fill a single operational void which, when left
      misunderstood, can result in serious security
      ramifications. This document does not attempt to document any
      other missing operational guidance for zone publishers.</t>
    </section>

    <section anchor="security" title="Security Considerations">
      <t>This document, is solely about the security considerations with
      respect to the SEP Publisher's ability to advertise new DNSKEYs
      via the RFC5011 automated trust anchor update process.
      Thus the entire document is a discussion of Security
      Considerations when adding or removing DNSKEYs from trust anchor
      storage using the RFC5011 process.</t>

      <t>For simplicity, this document assumes
      that the SEP Publisher will use a consistent RRSIG
      validity period.  SEP Publishers that vary the
      length of RRSIG validity periods will need to adjust the
      sigExpirationTime value accordingly so that the equations in
      <xref target="minimum" />  and <xref target="revoking" />
      use a value that coincides with the last time a replay of older
      RRSIGs will no longer succeed.</t>

    </section>

    <section title="Acknowledgements">
      <t>The authors would like to especially thank to Michael StJohns
      for his help and advice and the care and thought he put into
      RFC5011 itself and his continued reviews and suggestions for
      this document.  He also designed the suggested math behind the
      suggested safetyMargin values in <xref target="safetyMargin" />.
      </t>

      <t>We would also like to thank Bob Harold, Shane Kerr, Matthijs
      Mekking, Duane Wessels, Petr Petr Spacek, Ed Lewis, and the
      dnsop working group who have assisted with this document.</t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      <?rfc include='reference.RFC.2119'?>
      <?rfc include='reference.RFC.4033'?>
      <?rfc include='reference.RFC.5011'?>
      <?rfc include='reference.RFC.7583'?>
      <?rfc include='reference.RFC.7719'?>

    </references>

    <!--
                    <references title="Informative References">
                    </references>
                -->

    <section title="Real World Example: The 2017 Root KSK Key Roll">
      <t>In 2017 and 2018, ICANN expects to (or has, depending on when
      you're reading this) roll the key signing key (KSK) for the root
      zone. The relevant parameters associated with the root zone at
      the time of this writing is as follows:
      <figure>
          <artwork><![CDATA[
      addHoldDownTime:                      30 days
      Old DNSKEY sigExpirationTime:         21 days
      Old DNSKEY TTL:                        2 days
                ]]></artwork>
        </figure></t>

      <t>Thus, sticking this information into the equation in Section <xref
      target="minimum"/> yields (in days from publication time): <figure>
          <artwork><![CDATA[
  addWaitTime = 30
                + 21
                + MAX(1 hour,
                      MIN(21 / 2,     # activeRefresh
                          MAX(2) / 2,
                          15 days),
                      )
                + 30 % activeRefresh

  addWaitTime = 30 + 21 
                + MAX(1 hour, MIN(11.5, 1, 15)))
                + 30 % activeRefresh

  addWaitTime = 30 + 21 + 1 + 30%1

  addWaitTime = 30 + 21 + 1 + 0

  addWaitTime = 52 days 
                ]]></artwork>
        </figure></t>

      <t>Note that activeRefreshOffset ends up being 0, since 30 days is
      evenly divisible by activeRefresh (1 day).</t>

      <t>Also note that we exclude the safetyMargin value, which is
      calculated based on the expected client deployment size.</t>

      <t>Thus, ICANN must wait a minimum of 52 days before switching
      to the newly published KSK (and 26 days before removing the old
      revoked key once it is published as revoked).  ICANN's current
      plans involve waiting over 3 months before using the new KEY and
      69 days before removing the old, revoked key. Thus, their
      current rollover plans are sufficiently secure from the attack
      discussed in this memo.</t>
    </section>
  </back>
</rfc>
